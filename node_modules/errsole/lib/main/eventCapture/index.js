'use strict'

var Events = require('./events');
var Server = require('../connection/server');
var ProcessHook = require('../hooks/process');
var SessionLogs = require('../hooks/sessionLogs');
var SlowRequests = require('../hooks/slowRequests');
var jp = require('jsonpath');
const { v4: uuidv4 } = require('uuid');
const { match } = require("path-to-regexp");
var appConfig = require('../../config');
var pendingHTTPRequests = appConfig.getPendingHTTPRequests()

var EventCapturer = {};

var DataExtractionSchema = {};
var CaptureCriteria = {};

EventCapturer.initialize = function() {
  Events.on(Events.UNCAUGHT_EXCEPTION, uncaughtExceptionHandler);
  Events.on(Events.ADD_HTTP_REQUEST_LOG, addHttpRequestLogHandler);
  Events.on(Events.REMOVE_HTTP_REQUEST_LOG, removeHttpRequestLogHandler);
  Events.on(Events.HTTP_RESPONSE_SENT, httpResponseHandler);
  Events.on(Events.ROUTER_CONNECTION_ESTABLISHED, getEventCaptureCriteria);
  Events.on(Events.ADD_STDOUT_LOG, addStdoutHandler);
  Events.on(Events.ADD_STDERR_LOG, addStderrHandler);
}

async function uncaughtExceptionHandler(payload) {
  var frameworkName = appConfig.getFrameworkName();
  if(!payload || !payload.error) {
    ProcessHook.exitProcess(1);
    return false;
  }
  var data = {
    error: {
      code: payload.error.code,
      message: payload.error.message,
      stack: payload.error.stack
    }
  }
  if(frameworkName && frameworkName !== '') {
    data['logData'] = await getPendingHTTPRequestsData()
  }
  Server.call(Server.UNCAUGHT_EXCEPTION_HANDLER_URI, [], data)
  .then(function() {
    ProcessHook.exitProcess(1);
  })
  .catch(function(e) {
    ProcessHook.exitProcess(1);
  });
}


function addHttpRequestLogHandler(request) {
  if(!request || !request.errsole) {
    return false;
  }
  var reqId = request.errsole.id || uuidv4();
  pendingHTTPRequests[reqId] = request;
}

function removeHttpRequestLogHandler(request) {
  if(!request) {
    return false;
  }
  var reqId = request.errsole.id;
  if(reqId) {
    delete pendingHTTPRequests[reqId];
  }
}

async function getPendingHTTPRequestsData() {
  var logData = {}
  logData = getServerSchema()
    .then(function(keysSchema) {
      var pendingHTTPRequestsData = {};
      if(!keysSchema) {
        return {};
      }
      for(var reqId in pendingHTTPRequests) {
        var request = pendingHTTPRequests[reqId];
        var data = {
          'request': request
        }
        var requestData = extractData(data, keysSchema.requestKeys, keysSchema.deleteKeys);

        var skipRoutes = appConfig.getSkipRoutes();
        if(skipRoutes.length>0) {
          var isSkipRoute = verifySkipRoute(requestData.method, requestData.path);
        } else {
          var isSkipRoute = false;
        }

        var filterRoutes = appConfig.getFilterRoutes();
        if(filterRoutes.length>0) {
          var isFilterRoute = verifyFilterRoute(requestData.method, requestData.path);
        } else {
          var isFilterRoute = false;
        }

        if(requestData && !isSkipRoute) {
          var sessionData = extractData(data, keysSchema.sessionKeys, keysSchema.deleteKeys);
          try {
            var log = {
              id: uuidv4(),
              timestamp: new Date().getTime(),
              type: 'uncaught',
              path: requestData.path,
              routePath: requestData.routePath,
              method: requestData.method,
              data: {}
            }
            if(isFilterRoute) {
              var filteredRequestData = {
                method: requestData.method,
                path: requestData.path,
                routePath: requestData.routePath,
                isRequestFiltered: true
              }
              log.data['request'] = filteredRequestData;
              log.data['session'] = sessionData
            } else {
              log.data['request'] = requestData;
              log.data['session'] = sessionData
            }
            pendingHTTPRequestsData[reqId] = log;
          } catch(e) {
            console.error(e);
          }
        }
      }
      return Object.keys(pendingHTTPRequestsData).map((key) => pendingHTTPRequestsData[key]);
    });
  return logData;
}


function httpResponseHandler(payload) {
  if(!payload || !payload.response) {
    return false;
  }
  var response = payload.response || {};
  var responseStatusCode = response.statusCode || 0;
  var responseTimeThreshold = appConfig.getResponseTimeThreshold() || 0;
  var responseTime = payload.request?.errsole?.responseTime || 0;

  if(responseStatusCode < 400 && (parseInt(responseTime) < parseInt(responseTimeThreshold) || parseInt(responseTimeThreshold) === 0)) {
    return false;
  }

  getServerSchema()
  .then(function(keysSchema) {
    if(!keysSchema) {
      return false;
    }
    var requestData = extractData(payload, keysSchema.requestKeys, keysSchema.deleteKeys);

    var skipRoutes = appConfig.getSkipRoutes();
    if(skipRoutes.length>0) {
      var isSkipRoute = verifySkipRoute(requestData.method, requestData.path);
      if(isSkipRoute) {
        return false;
      }
    } else {
      var isSkipRoute = false;
    }

    var enableSessionLogs = appConfig.getEnableSessionLogs();
    if(responseStatusCode < 400 && (parseInt(responseTime) >= parseInt(responseTimeThreshold) || parseInt(responseTimeThreshold) !== 0) && enableSessionLogs === false) {
      if(responseTime!==0) {
        var responseTime = payload.request?.errsole?.responseTime || 0;
        var isSlowRequestExist = SlowRequests.checkSlowHTTPRequestExist(requestData, responseTime);
        if(isSlowRequestExist) {
          return false;
        }
      }
    }

    var filterRoutes = appConfig.getFilterRoutes();
    if(filterRoutes.length>0) {
      var isFilterRoute = verifyFilterRoute(requestData.method, requestData.path);
    } else {
      var isFilterRoute = false;
    }

    var responseData = extractData(payload, keysSchema.responseKeys, keysSchema.deleteKeys);
    var sessionData = extractData(payload, keysSchema.sessionKeys, keysSchema.deleteKeys);
    var errorData = extractData(payload, keysSchema.errorKeys, keysSchema.deleteKeys);
    var matchedCriteria = matchCriteria(requestData, responseData);
    var data = {
      request: requestData,
      response: responseData,
      session: sessionData,
      error: errorData
    };
    if(isFilterRoute) {
      var filterData = {
        request: {
          method: data.request.method,
          path: data.request.path,
          routePath: data.request.routePath,
          isRequestFiltered: true
        },
        response: {
          statusCode: data.response.statusCode,
          statusMessage: data.response.statusMessage
        },
        session: sessionData,
        error: errorData
      }
    } else {
      var filterData = null;
    }
    if (matchedCriteria.length>0) {
      matchedCriteria.forEach(function(criteria) {
        if(criteria.isHTTPException) {
          Server.call(Server.HTTP_EXCEPTION_URI, [], filterData || data).catch(console.error);
        }
      });
    }
    var errsoleSessionId = payload.request.errsole.errsoleSessionId;
    if(enableSessionLogs) {
      SessionLogs.addHTTPResponseLog(errsoleSessionId, 'http', filterData || data);
    }
    var responseTimeThreshold = appConfig.getResponseTimeThreshold();
    var responseTime = payload.request.errsole.responseTime;
    if(parseInt(responseTimeThreshold) < parseInt(responseTime)) {
      SlowRequests.addSlowHTTPRequest(filterData || data, parseInt(responseTime));
    }
  });
}

function matchCriteria(requestData, responseData) {
  var matches = [];
  if (CaptureCriteria.statusCodes && CaptureCriteria.statusCodes.indexOf(responseData.statusCode) >= 0) {
    matches.push({
      isHTTPException: true
    });
  }
  return matches;
}


function preprocessEventData(eventData, keyMap) {
  Object.keys(keyMap).forEach(key => {
    if (keyMap[key] === '$.response._headers') {
      keyMap[key] = '$.response.headerData';
      if (eventData.response && typeof eventData.response.getHeaders === 'function') {
        eventData.response['headerData'] = eventData.response.getHeaders();
      }
    }
  });
}

function extractData(data, keyMap, deleteKeys) {
  var eventData = Object.assign({}, data);
  var data = {};
  preprocessEventData(eventData, keyMap);

  if(typeof keyMap !== 'object' || typeof deleteKeys !== 'object') {
    return null;
  }

  try {
    for(var key in deleteKeys) {
      var keyData = deleteKeys[key];
      jp.apply(eventData, keyData, function(v) { return null; });
    }
  } catch(e) { console.error(e); }

  try {
    for(var key in keyMap) {
      var keyData = keyMap[key];
      var temp = jp.value(eventData, keyData);
      if(!temp) {
        temp = null;
      } else {
        data[key] = temp;
      }
    }
  } catch(e) { console.error(e); }

  return data;
}

function getEventCaptureCriteria() {
  var frameworkName = appConfig.getFrameworkName();
  if(!frameworkName || frameworkName == '') {
    return false;
  }
  Server.call(Server.GET_EVENT_CAPTURE_CRITERIA_URI)
  .then(function(result) {
    Object.assign(CaptureCriteria, result);
    Server.subscribe(Server.EVENT_CAPTURE_CRITERIA_UPDATED_URI, function(args, kwargs) {
      Object.assign(CaptureCriteria, kwargs);
    });
    setInterval(function(){ updateEventCaptureCriteria(); }, 1000*60*2);
    getServerSchema();
  })
  .catch(function(err) {
    console.error(err);
  });
}

function updateEventCaptureCriteria() {
  Server.call(Server.GET_EVENT_CAPTURE_CRITERIA_URI)
  .then(function(result) {
    Object.assign(CaptureCriteria, result);
  })
  .catch(function(err) {
    console.error(err);
  });
}

function getServerSchema() {
  var frameworkName = appConfig.getFrameworkName();
  if (DataExtractionSchema[frameworkName]) {
    return Promise.resolve(DataExtractionSchema[frameworkName]);
  }
  var data = {
    'frameworkName': frameworkName,
    'frameworkVersion': '',
    'nodeVersion': process.versions.node
  }
  return Server.call(Server.NODE_FRAMEWORK_KEYS, [], data)
  .then(function(result) {
    if(Object.keys(result).length == 0) {
      console.error(new Error('Errsole Internal Error: Failed to get the framework schema. Please report the issue at https://github.com/errsole/errsole/issues'));
    } else {
      appConfig.setNodeFrameworkKeys(frameworkName, result);
      DataExtractionSchema[frameworkName] = result;
      return result;
    }
  }).catch(function(err) {
    console.error(new Error('Errsole Internal Error: '+(err.message || err.toString())+'. Please report the issue at https://github.com/errsole/errsole/issues'));
  });
}


function verifyFilterRoute(method, path) {
  var status = false;
  var filterRoutes = appConfig.getFilterRoutes();
  var routes = filterRoutes.filter((filterRoute)=> filterRoute.method.toLowerCase() == method.toLowerCase());
  for(var key in routes) {
    var routePath = routes[key]['path'];
    if(routePath && path) {
      path = path.split("?")[0];
      try {
        const fn = match(routePath.toLowerCase(), { decode: decodeURIComponent });
        status = fn(path.toLowerCase());
        if(status) break;
      } catch(err) {
        console.error(err);
      }
    }
  }
  return status;
}

function verifySkipRoute(method, path) {
  var status = false;
  var skipRoutes = appConfig.getSkipRoutes();
  var routes = skipRoutes.filter((skipRoutes)=> skipRoutes.method.toLowerCase() == method.toLowerCase());
  for(var key in routes) {
    var routePath = routes[key]['path'];
    if(routePath && path) {
      path = path.split("?")[0];
      try {
        const fn = match(routePath.toLowerCase(), { decode: decodeURIComponent });
        status = fn(path.toLowerCase());
        if(status) break;
      } catch(err) {
        console.error(err);
      }
    }
  }
  return status;
}

function addStdoutHandler(data) {
  if (Server.socketio && Server.socketio.connected) {
    Server.callSocketio(Server.CAPTURE_STDOUT_URI, data);
  }
}

function addStderrHandler(data) {
  if (Server.socketio && Server.socketio.connected) {
    Server.callSocketio(Server.CAPTURE_STDERR_URI, data);
  }
}

module.exports = EventCapturer;
