'use strict'

const FS = require('fs');
const Path = require('path');
const { v4: uuidv4 } = require('uuid');

var Events = require('../../eventCapture/events');
var appConfig = require('../../../config');

var pendingHTTPRequests = appConfig.getPendingHTTPRequests()

var KoaHook = {};
var isKoaWrapped = false;

function wrapKoa(_koa) {
  class Koa {
    constructor() {
      var self = this;
      this._app = new _koa();
      this._app.use(errsoleWatcher);
      this._app.use(errsoleResponseCapture);
      this._app.on('error', errsoleErrorHandler);
      return this._app;
    }
  }
  return Koa;
}

function wraplisten(_listen, app) {
  return function () {
    var port = arguments[0];
    appConfig.addMainProcessPort(port);
    appConfig.addWrappedPorts(port);
    return _listen.call(app, ...arguments);
  }
}

function errsoleErrorHandler(err, ctx) {
  if(ctx.req && ctx.req.errsole) {
    ctx.req.errsole.error = err;
  } else if(ctx.req) {
    ctx.req.errsole ={};
    ctx.req.errsole.error = err;
  }
}

async function errsoleWatcher(ctx, next) {
  var req = ctx.req;
  var res = ctx.res;
  req.errsole = {};
  req.errsole.id = uuidv4();
  Events.emit(Events.ADD_HTTP_REQUEST_LOG, req);

  var reqStartTime = process.hrtime.bigint();

  var errsoleSessionId = getErrsoleSessonId(req);
  if(!errsoleSessionId) {
    var errsoleSessionId = uuidv4();
    setErrsoleSessionId(ctx, errsoleSessionId)
  }

  var afterResponse = function() {
    req.errsole.responseTime = ((process.hrtime.bigint() - reqStartTime)/1000000n).toString();
    req.errsole.errsoleSessionId = errsoleSessionId;
    Events.emit(Events.REMOVE_HTTP_REQUEST_LOG, req);
    Events.emit(Events.HTTP_RESPONSE_SENT, {
      request: req,
      response: res
    });
  };

  if(res._events) {
    if(res._events.finish) {
      res.on('finish', afterResponse);
    } else if(res._events.close) {
      res.on('close', afterResponse);
    } else {
      throw new Error('unable to attach error watcher');
    }
  } else {
    throw new Error('unable to attach error watcher');
  }
  await next();
}

async function errsoleResponseCapture(ctx, next) {
  var req = ctx.req;
  var res = ctx.res;
  if(!ctx.req.errsole) {
    ctx.req.errsole ={};
  }
  req.errsole.responseBody = '';
  var _resWrite = res.write;
  res.write = function write(chunk, encoding, callback) {
    if (!chunk) {
      req.errsole.responseBody += '';
    } else if (Buffer.isBuffer(chunk)) {
      req.errsole.responseBody += chunk.toString(encoding);
    } else if (typeof chunk === 'string') {
      req.errsole.responseBody += chunk;
    } else {
      req.errsole.responseBody = 'Response not available';
    }
    _resWrite.call(res, chunk, encoding, callback);
  };
  if (parseInt(process.versions.node) >= 8) {
    var _resEnd = res.end;
    res.end = function end(chunk, encoding) {
      if (!chunk) {
        req.errsole.responseBody += '';
      } else if (Buffer.isBuffer(chunk)) {
        req.errsole.responseBody += chunk.toString(encoding);
      } else if (typeof chunk === 'string') {
        req.errsole.responseBody += chunk;
      } else {
        req.errsole.responseBody = 'Response not available';
      }
      _resEnd.call(res, chunk, encoding);
    };
  }
  await next();
};

function getErrsoleSessonId(req) {
  try {
    if(req.headers && req.headers.cookie) {
      var sessionName = appConfig.getSessionName();
      var errsoleSessionId = get_cookies(req)[sessionName];
      if(errsoleSessionId) {
        return errsoleSessionId;
      }
    } else {
      return null;
    }
  } catch(e) {
    console.error(e);
    return null;
  }
}

function setErrsoleSessionId(ctx, errsoleSessionId) {
  try {
    var sessionName = appConfig.getSessionName();
    ctx.cookies.set(sessionName, errsoleSessionId);
  } catch(e) {
    console.error(e);
  }
}

function get_cookies(request) {
  var cookies = {};
  try {
    request.headers && request.headers.cookie.split(';').forEach(function(cookie) {
      var parts = cookie.match(/(.*?)=(.*)$/)
      cookies[ parts[1].trim() ] = (parts[2] || '').trim();
    });
  } catch(e) {}
  return cookies;
}

KoaHook.setupHandler = function(app) {
  if(!isKoaWrapped) {
    app.use(errsoleWatcher);
    app.use(errsoleResponseCapture);
    app.listen = wraplisten(app.listen, app);
    process.nextTick(function() {
      app.use(errsoleErrorHandler);
    });
  }
}

KoaHook.packages = [{
    name: 'koa',
    wrapper: wrapKoa
  }
];

module.exports = KoaHook;
