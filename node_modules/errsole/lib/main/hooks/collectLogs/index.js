const stream = require('stream');
const stripAnsi = require('strip-ansi');
var Events = require('../../eventCapture/events');
var appConfig = require('../../../config');

const LogLevel = {
  INFO: 'info',
  ERROR: 'error'
};

const CollectLogsHook = {
  logQueue: [],
  socketStatus: 'unready',
  maxQueueSize: 1000
};

CollectLogsHook.initialize = function() {
  var collectLogs = appConfig.getLoggingStatus();
  if(collectLogs.includes(LogLevel.INFO)) {
    this.collectLogs(LogLevel.INFO);
  }
  if(collectLogs.includes(LogLevel.ERROR)) {
    this.collectLogs(LogLevel.ERROR);
  }
  Events.on(Events.SOCKETIO_CONNECTION_STATUS_CHANGE, this.updateSocketStatus.bind(this));
};

CollectLogsHook.updateSocketStatus = function(newStatus) {
  if(this.socketStatus === 'unready' && newStatus === 'ready') {
    this.flushQueue();
  }
  this.socketStatus = newStatus;
};

CollectLogsHook.flushQueue = function() {
  const batchSize = 50;
  const delay = 2000;
  const flushBatch = () => {
    for (let i = 0; i < batchSize; i++) {
      if (this.logQueue.length === 0) {
        break;
      }
      var logEntry = this.logQueue.shift();
      Events.emit(logEntry.level === LogLevel.INFO ? Events.ADD_STDOUT_LOG : Events.ADD_STDERR_LOG, logEntry);
    }
    if (this.logQueue.length > 0) {
      setTimeout(flushBatch, delay);
    }
  };
  flushBatch();
};



function enqueueLog(logEntry) {
  if (CollectLogsHook.socketStatus === 'ready') {
    Events.emit(logEntry.level === LogLevel.INFO ? Events.ADD_STDOUT_LOG : Events.ADD_STDERR_LOG, logEntry);
  } else if (CollectLogsHook.socketStatus === 'unready') {
    if (CollectLogsHook.logQueue.length < CollectLogsHook.maxQueueSize) {
      CollectLogsHook.logQueue.push(logEntry);
    }
  }
}


CollectLogsHook.collectLogs = function(level) {
  const logBuffer = new stream.Writable();
  logBuffer._write = function(chunk, encoding, done) {
    const cleanedChunk = stripAnsi(chunk.toString());
    const logEntry = { message: cleanedChunk, level: level, timestamp: new Date().toISOString() };
    enqueueLog(logEntry);
    done();
  };

  const originalWrite = level === LogLevel.INFO ? process.stdout.write : process.stderr.write;
  const writeFunction = level === LogLevel.INFO ? process.stdout : process.stderr;

  writeFunction.write = function() {
    const argsArray = Array.from(arguments);
    originalWrite.apply(writeFunction, argsArray);
    logBuffer.write.apply(logBuffer, argsArray);
  };
};

module.exports = CollectLogsHook;
